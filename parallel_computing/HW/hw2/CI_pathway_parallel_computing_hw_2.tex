\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage{booktabs}
\usepackage{array}
\usepackage[utf8]{inputenc}



\usepackage{epstopdf}
\usepackage{caption}


\usepackage[fleqn]{amsmath}



\usepackage{tipx}
\usepackage{tipa}

\usepackage{breakcites}
%\usepackage{/usr/local/texlive/2020/texmf-dist/tex/latex/breakcites/breakcites}

%\usepackage{supertabular}
%\usepackage{wasysym}

%\usepackage{setspace}

%\usepackage{pifont}



\usepackage{enumitem}

\usepackage{float} %%%% use H! position -- conserve vertical space

%\usepackage{mathabx}


%\usepackage{txfonts}


%\usepackage{Sweave}

\usepackage{fancyvrb} %%% for \VerbatimInput


%%%%%%%%%%%%%%%%%%%%%%%% FOR HYPER REF
\usepackage{xcolor}
\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0}
\definecolor{MyDarkRed}{rgb}{0.4,0.0,0.0} 
\definecolor{MyBlue}{rgb}{0.0, 0.0, 0.5} 

\definecolor{MyOrange1}{rgb}{1.0, 0.9, 0.0} 

\usepackage[colorlinks=true, urlcolor= MyDarkRed, linkcolor= MyBlue, citecolor=MyDarkGreen ]{hyperref}

%\usepackage[colorlinks=false, urlcolor= MyOrange1, linkbordercolor=MyOrange1, citecolor=MyDarkGreen ]{hyperref}

\usepackage{makeidx}

\usepackage{listings}
\lstdefinestyle{dm4ds_lstCustom_01}{
  basicstyle=\ttfamily\footnotesize,
  breaklines=true
}
\input{_latexFormatting_01.tex}


\usepackage{geometry}

\usepackage{textcomp}
\usepackage{multirow}
\usepackage{float}

%\usepackage[colorlinks=true, urlcolor= \rgb{0.0,0.2,0.0}  ]{hyperref}




%\singlespacing
%\onehalfspacing
%\doublespacing

%\pagestyle{empty} %% turn off page numbering

\DeclareCaptionLabelSeparator{space}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\textwidth = 6.5 in
\textheight = 8.2 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.7 in
\parskip = 0.2in
\parindent = 0.0in
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}
%\title{Brief Article}
%\author{The Author}



\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\makeindex

\begin{document}


%\newcommand\textcode\Verb


%\maketitle



\newif\ifuselocaldir
\uselocaldirtrue
\uselocaldirfalse


\newcommand{\DXZ}{
\begin{flushright}
\vspace{-.4in}
 { \raisebox{0.30ex}{{\tiny D}}\hspace{0.008in}X\hspace{0.01in}\raisebox{0.30ex}{{\tiny Z}}     }
\end{flushright}
}


\newenvironment{myQuote}[2]%
               {\begin{list}{}{\leftmargin#1\rightmargin#2}\item{}}%
               {\end{list}}

\begin{myQuote}{2cm}{2cm}
\begin{center}
{\huge
\textbf{CI Pathway: Parallel Computing} \\[0.4cm]
Assignment - 2
} \\[0.4cm]
\end{center}
\end{myQuote}

%\begin{myQuote}{3cm}{3cm}
%\begin{center}
%PRILIMINARY \& INCOMPLETE \\
%\end{center}
%\end{myQuote}



\begin{myQuote}{3cm}{3cm}
{\normalsize
\begin{center}
UCLA, Statistics\\Hochan Son\\Summer 2025\\
\today
%2012-03-12
\end{center}
}
\end{myQuote}


%\begin{abstract}
%{\normalsize
%Here's my abstract
%}
%\end{abstract}


%\newpage


%%\tableofcontents


%\newpage


%\input{_example.tex}

%\chapter{Introduction}

%Our textbook is \cite{briney2015data}.


%%%%%%%%%%%%%%%%




\section{Introduction}
This analysis evaluates parallel computing performance exerise for prime number . The study compares four implementation approaches across varying thread/process counts to assess scalability and efficiency characteristics.

\section{Hardware Environment}

\subsection{System Specifications}
The experiments were conducted on the NCSA Delta HPC cluster, which is a high-performance computing environment designed for parallel processing tasks. The specifications of the system are as follows:
\begin{table}[H]
\centering
\caption{NCSA Delta Compute Environment}
\label{tab:system_specs}
\begin{tabular}{@{}ll@{}}
\hline
\textbf{Component} & \textbf{Specification} \\
\hline
Compute Platform & NCSA Delta HPC Cluster \\
Login Node & dt-login04.delta.ncsa.illinois.edu \\
Compute Node & cn094.delta.ncsa.illinois.edu \\
Operating System & Linux 4.18.0-477.95.1.el8\_8.x86\_64 \\
Distribution & Red Hat Enterprise Linux 8 \\
Architecture & x86\_64 \\
Node Interconnect & HPE Slingshot \\
\hline
\end{tabular}
\end{table}


\subsection{Processor Architecture}

\begin{table}[H]
\centering
\caption{AMD EPYC 7763 Processor Specifications}
\label{tab:processor_specs}
\begin{tabular}{@{}ll@{}}
\hline
\textbf{Parameter} & \textbf{Value} \\
\hline
CPU Model & AMD EPYC 7763 64-Core Processor \\
Architecture & AMD Zen 3 (Milan) \\
Physical Cores & 64 per socket \\
Hardware Threads & 128 (2-way SMT) \\
Base Clock & 2.45 GHz \\
Boost Clock & Up to 3.5 GHz \\
Manufacturing Process & 7nm TSMC \\
Socket Type & SP3 \\
\hline
\end{tabular}
\end{table}



\section{Exercises For This Module.}

%\newgeometry{top=1cm, left=1cm, right=1cm}
%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=17.5cm]{_assets/bigStudentPicArray_01.jpeg}
%\caption{UCLA Graduate Statistics Students}
%\label{fig:studentArray}
%\end{center}
%\end{figure}
%\restoregeometry


\subsection{OpenMP Exercise}

\begin{enumerate}
  \item{You will find this code in \texttt{\/projects\/becs\/urbanic} as either \texttt{prime\_serial.c or prime\_serial.f}.
  \\
  \\Your job is to accelerate this code using OpenMP. You should see a dramatic speedup if you use our OpenMP directives effectively.
  \\
  \\If you are not careful, you could introduce a race condition and have inconsistent results. If you use the same caution we used in the examples above, you will avoid this.
  \\
  \\To reiterate what you did in the previous module.
  \begin{enumerate}
    \item {Compile with something like
    \begin{verbatim}
      nvc -mp prime_serial.c
      or
      nvfortran -mp prime_serial.f
    \end{verbatim}
    }
    \item {Grab multiple cores on a compute node with something like
    \begin{verbatim}
      srun --account=becs-delta-cpu --partition=cpu-interactive \
      --nodes=1 --cpus-per-task=32 --pty bash
    \end{verbatim}
    }
    \item {Set the number of threads you wish to run with using something like
    \begin{verbatim}
        export OMP_NUM_THREADS=16
    \end{verbatim}
    }
    Submit your code and your timings for at least 1, 4, 8, 16 and 32 threads.
  \end{enumerate}

\section{Solution:}

% \begin{enumerate}
%   \item{Exercise 1: Compile, run, and time the Laplace code using the two programming models in this Pathway: OpenMP and MPI.}
%     Vary the number of cores up to 32 by changing the \texttt{OMP\_NUM\_THREADS} environment variable to see what speedup you experience. Record these times.


%   \item{Exercise 2: Execute a single timing run, using 4 processes, and record the time obtained.}

% \end{enumerate}



% \section {Solutions: OpenMP and MPI Performance Analysis}

% \subsection {Serial, OpenMP, and Enhanced Parallel Processing}
%   The purpose of this exerise to measure the differeneces how the parallelism benefits the speed of the execution by distributed computation over multiple cpu cores. I've done few observations.
%   1. varying threads (1,8, and 32) on \texttt{OMP\_NUM\_THREADS} counts. 
%   2. varying techniques such as serial, openmp, and red-black (checkerboard algorithm) by complier tuning. 
%   The performance evaluation reveals significant differences across parallelization approaches, as summarized in the following tables.\\
%   Each of the process has completed with 1,8, and 32 threads. It has shown that the serial process has no performance improvement across threads counts. The OpenMP has shown good performance. Although Enhanced Parallel test with red-black checker board algorithm has the best outcome at threads=32. 
%   However, the efficiency on 32 threads has decreasing. As thread count increases, efficiency typically decreases due to parallel overhead, communication costs, and workload imbalances.

%   \begin{table}[H]
%   \centering
%   \caption{Parallel Processing Performance Comparison}
%   \label{tab:performance_comparison}
%   \footnotesize
%   \begin{tabular}{lccccc}
%   \hline
%   \textbf{Method} & \textbf{Threads} & \textbf{Time (s)} & \textbf{Speedup} & \textbf{Efficiency (\%)} & \textbf{Iterations} \\
%   \hline
%   Serial Process Test & 1  & 22.040 & 1.00$\times$ & 100.0 & 3372 \\
%   Serial Process Test & 8  & 22.037 & 1.00$\times$ & 12.5  & 3372 \\
%   Serial Process Test & 32 & 22.065 & 1.00$\times$ & 3.1   & 3372 \\
%   \hline
%   OpenMP Process Test & 1  & 21.733 & 1.00$\times$ & 100.0 & 3372 \\
%   OpenMP Process Test & 8  & 4.175  & 5.21$\times$ & 65.1  & 3372 \\
%   OpenMP Process Test & 32 & 1.992  & 10.91$\times$ & 34.1 & 3372 \\
%   \hline
%   Enhanced (Red/Black) Parallel Test & 1  & 12.738 & 1.00$\times$ & 100.0 & 3279 \\
%   Enhanced (Red/Black) Parallel Test & 8  & 2.569  & 4.96$\times$ & 62.0  & 3279 \\
%   Enhanced (Red/Black) Parallel Test & 32 & 1.490  & 8.55$\times$ & 26.7  & 3279 \\
%   \hline
%   \end{tabular}
%   \end{table}
  
%   \begin{itemize}
%     \item \textbf{Serial Test}: Shows no parallelization benefit, confirming serial execution regardless of thread count.
    
%     \item \textbf{OpenMP Implementation}: 
%     \\Demonstrates significant speedup with increasing thread count:
%       \begin{itemize}
%       \item 8 threads: 5.21$\times$ speedup (65.1\% efficiency)
%       \item 32 threads: 10.91$\times$ speedup (34.1\% efficiency)
%       \end{itemize}
    
%     \item \textbf{Enhanced Red/Black (checkerboard algorithm) Method}: Achieves best overall performance:
%       \begin{itemize}
%       \item Superior single-thread performance (12.738s vs 21.733s)
%       \item Best 32-thread performance (1.490s vs 1.992s)
%       \item 25.2\% faster than OpenMP at 32 threads
%       \item Slight reduction in required iterations (3279 vs 3372)
%       \end{itemize}
    
%     \item \textbf{Efficiency Analysis}: Both parallel methods show decreasing efficiency with higher thread counts, typical of parallel overhead and diminishing returns.
  
%   \end{itemize}

% \subsection {Serial, MPI Processing}

\section*{Conclusion}


%\newpage{}
%\pagebreak{}

\bibliographystyle{plain}

\bibliography{Lab_X} 


\newpage

\section{Appendix.code}

Here's some of our code (Note the use of VerbatimInput from package \texttt{fancyvrb}):


\subsection{Code A: prime\_serial.c}

%\begin{footnotesize}
%\VerbatimInput{_code_A.R}
%\end{footnotesize}

\begin{footnotesize}
\lstinputlisting[style=dm4ds_lstCustom_01]{./prime_serial.c}
\end{footnotesize}




\subsection{Code B: prime\_parallel.c}

%\begin{footnotesize}
%\VerbatimInput{_code_B.R}
%\end{footnotesize}

\begin{footnotesize}
\lstinputlisting[style=dm4ds_lstCustom_01]{./prime_parallel.c}
\end{footnotesize}




% \subsection{Code C: laplace\_omp\_parallel.c}

% %\begin{footnotesize}
% %\VerbatimInput{_code_C.R}
% %\end{footnotesize}

% \begin{footnotesize}
% \lstinputlisting[style=dm4ds_lstCustom_01]{ex1/laplace_omp_parallel.c}
% \end{footnotesize}


% \subsection{Code D: laplace\_mpi.c}

% %\begin{footnotesize}
% %\VerbatimInput{_code_C.R}
% %\end{footnotesize}

% \begin{footnotesize}
% \lstinputlisting[style=dm4ds_lstCustom_01]{ex2/laplace_mpi.c}
% \end{footnotesize}



\section{Appendix.results}

\subsection{result.txt}
\begin{footnotesize}
 \lstinputlisting[style=dm4ds_lstCustom_01]{./result.txt}
\end{footnotesize}

% \subsection{ex2\_result.txt}
% \begin{footnotesize}
%  \lstinputlisting[style=dm4ds_lstCustom_01]{ex2/ex2_result.txt}
% \end{footnotesize}


\end{document}